
<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>mat.js</title>
	<!--<script 
		type="text/javascript" 
		src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>-->
	<script type="text/javascript" src="src/mat.js"></script>
</head>

<style>

	body {
		font-family: 'Helvetica Neue', Helvetica, Arial, Serif;
		font-size: 12px;
		color: #222;

		margin: 0;
		padding: 0;
		width 100%;

		background: #fefefe;
	}

	pre {
		width: 680px;
		border: 1px solid #ccc;
		border-radius: 3px;
		background: #fff;
		padding: 10px;
	}

	code {
		border: 1px solid #ccc;
		border-radius: 3px;
		padding-left: 4px;
		padding-right: 4px;
	
		display: inline-block;
		line-height: 18px;
		background: #fff;
	}

	a {
		text-decoration: none;	
	}

	ol li {
		line-height: 16px;
	}

	#container {
		width: 960px;
		margin: 0 auto;
	}

	.left {
		float: left;
		width: 240px;
	}

	.right {
		float: right;
		width: 700px;
	}

	ul#menu {
		list-style-type: none;
		margin: 0;
		margin-top: 1.245em;
		padding: 0;
	}

	ul#menu li {
		width: 100%;
		position: relative;
		display: block;
	}

	ul#menu li a {
		width: 100%;
		display: block;
		padding-left: 10px;
		line-height: 24px;
	}

	ul#menu li span {
		font-weight: bold;
		font-size: 16px;
		color: #444;
	}

	div.section h2 {
		border-bottom: 1px dashed #ccc;
	}

	div.section a.top {
		display: none;
		position: relative;
		float: right;
		margin-top: 5px;
	}

	div.section:hover a.top {
		display: block;
	}
</style>

<body>
	<div id="container">
		<div class="left">
			<ul id="menu">
				<li><span>Table of contents</span></li>
				<li><a href="#introduction">Introduction</a></li>
				<li><span>Attributes</span></li>
				<li><a href="#error">error</a></li>
				<li><a href="#maxrounds">maxrounds</a></li>
				<li><a href="#overwrite">overwrite</a></li>
				<li><span>Methods</span></li>
				<li><a href="#fromArray">fromArray</a></li>
				<li><a href="#toArray">toArray</a></li>
				<li><a href="#toString">toString</a></li>
				<li><a href="#getColumn">getColumn</a></li>
				<li><a href="#getColumns">getColumns</a></li>
				<li><a href="#getLength">getLength</a></li>
				<li><a href="#getRow">getRow</a></li>
				<li><a href="#getRows">getRows</a></li>
				<li><a href="#getShape">getShape</a></li>
				<li><a href="#getValue">getValue</a></li>
				<li><a href="#getValues">getValues</a></li>
				<li><a href="#setRows">setRows</a></li>
				<li><a href="#setColumns">setColumns</a></li>
				<li><a href="#setValue">setValue</a></li>
				<li><a href="#isSquare">isSquare</a></li>
				<li><a href="#isColumnVector">isColumnVector</a></li>
				<li><a href="#isRowVector">isRowVector</a></li>
				<li><a href="#isVector">isVector</a></li>
				<li><a href="#isSameSize">isSameSize</a></li>
				<li><a href="#add">add</a></li>
				<li><a href="#subtract">subtract</a></li>
				<li><a href="#product">product</a></li>
				<li><a href="#hadamardProduct">hadamardProduct</a></li>
				<li><a href="#scalarProduct">scalarProduct</a></li>
				<li><a href="#transpose">transpose</a></li>
				<li><a href="#hermitian">hermitian</a></li>
				<li><a href="#trace">trace</a></li>
				<li><a href="#upperTrace">upperTrace</a></li>
				<li><a href="#lowerTrace">lowerTrace</a></li>
				<li><a href="#minor">minor</a></li>
				<li><a href="#determinant">determinant</a></li>
				<li><a href="#det">det</a></li>
				<li><a href="#gaussElimination">gaussElimination</a></li>
				<li><a href="#solve">solve</a></li>
				<li><a href="#gramSchmidt">gramSchmidt</a></li>
				<li><a href="#qrDecomposition">qrDecomposition</a></li>
				<li><a href="#qr">qr</a></li>
				<li><a href="#luDecomposition">luDecomposition</a></li>
				<li><a href="#lu">lu</a></li>
				<li><a href="#eigenValues">eigenValues</a></li>
				<li><a href="#eigenVectors">eigenVectors</a></li>
				<li><a href="#identity">identity</a></li>
				<li><a href="#diagonal">diagonal</a></li>
				<li><a href="#pNorm">pNorm</a></li>
				<li><a href="#norm">norm</a></li>
				<li><a href="#toToeplitz">toToeplitz</a></li>
				<li><a href="#inverse">inverse</a></li>
				<li><a href="#pseudoInverse">pseudoInverse</a></li>
				<li><a href="#toVandermonde">toVandermonde</a></li>
				<li><a href="#zero">zero</a></li>
			</ul>
		</div>
		<div class="right">
			<div class="section" id="introduction">
				<h2>Introduction</h2>
				<p>This library is not intended to be taken seriously, as it is made just for fun and learning purposes. One may find it useful but any use in production environments, research studies, etc. is discouraged.</p>
				<p>This javascript matrix library comes from the need to perform various numeric matrix operations during the course of some assignments at college. The lack of one of those fancy graphic calculators, my reluctance in spending money buying one and the growing interest in javascript took me to start writing most of the code found here. After six months or so I have managed to put this sort of library and learned some more linear algebra and algorithms during the process.</p>
				<p>In case you find this useful, or end up ignoring my first advice and use it somewhere, I will be delighted to know it so feel free to mail me at the email address found in the source code. Moreover, if you happen to find any mistakes (I am pretty sure there are a ton of them) in the source code or in this document, you can issue them at its github repository at <a href="https://github.com/dhuertas/mat.js" target="_blank">https://github.com/dhuertas/mat.js</a>.</p>
				<p>Happy coding!</p>
			</div>
			<div class="section" id="error">
				<a class="top" href="#">top</a>
				<h2>error</h2>
				<p class="description">(float) - Sets the error resolution for the iterative algorithms (e.g. <a href="#eigenValues">eigenValues</a>, <a href="#eigenVectors">eigenVectors</a>).</p>
				<h3>Default:</h3>
				<pre>0.000001</pre>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [1, 2, 3, 4]);
A.error = 0.000001;</pre>
				<span>or</span>
				<pre>
var A = new MAT({
	rows: 2,
	columns: 2, 
	values: [1, 2, 3, 4], 
	error: 0.000001});</pre>
			</div>
			<div class="section" id="maxrounds">
				<a class="top" href="#">top</a>
				<h2>maxrounds</h2>
				<p class="description">(integer) - Sets the number of maximum rounds for the iterative algorithms (e.g. <a href="#eigenValues">eigenValues</a>, <a href="#eigenVectors">eigenVectors</a>).</p>
				<h3>Default:</h3>
				<pre>1000</pre>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [1, 2, 3, 4]);
A.maxrounds = 1000;</pre>
			<span>or</span>
			<pre>
var A = new MAT({
	rows: 2,
	columns: 2,
	values: [1, 2, 3, 4],
	maxrounds: 1000});</pre>
			</div>
			<div class="section" id="overwrite">
				<a class="top" href="#">top</a>
				<h2>overwrite</h2>
				<p class="description">When set to <code>true</code> the result values will be stored in the same matrix instance, overwriting the previous ones (not to be confused with in-place algorithms). The aim is to reduce the amount of memory and time used to perform iterative operations.</p>
				<h3>Default:</h3>
				<pre>false</pre>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2,2,[1, 2, 3, 4]);
A.overwrite = true;</pre>
				<span>or</span>
				<pre>
var A = new MAT({
	rows: 2,
	columns: 2,
	values: [1, 2, 3, 4],
	overwrite: true});</pre>
			</div>
			<div class="section" id="fromArray">
				<a class="top" href="#">top</a>
				<h2>fromArray</h2>
				<p class="description">Creates a new matrix using array notation.</p>
				<h3>Syntax:</h3>
				<pre>.fromArray(array);</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(array) - A 2D array containing the matrix values.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix.</li>
				</ul>
				<h3>Example:</h3>
				<p>This example creates a 2x3 matrix object:</p>
				<pre>
var A = new MAT({
	maxrounds: 1000,
	overwrite: true
}).fromArray([
	[1, 2, 3],
	[4, 5, 6]
]);</pre>
			</div>
			<div class="section" id="toArray">
				<a class="top" href="#">top</a>
				<h2>toArray</h2>
				<p class="description">Returns an array containing all the matrix values, ordered from left to right and from top to bottom.</p>
				<h3>Syntax:</h3>
				<pre>.toArray()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>	
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A copy of the array containing the matrix values.</li>
				</ul>
				<h3>Example:</h3>
				<pre>var values = A.toArray();</pre>
			</div>
			<div class="section" id="toString">
				<a class="top" href="#">top</a>
				<h2>toString</h2>
				<p class="description">Returns a string containing all the matrix values, using the toString method of the javascript <code>Array</code> object.</p>
				<h3>Syntax:</h3>
				<pre>.toString()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(string) - The toString method applied to the matrix array.</li>
				</ul>
				<h3>Example:</h3>
				<pre>document.write(A.toString());</pre>
			</div>
			<div class="section" id="getColumn">
				<a class="top" href="#">top</a>
				<h2>getColumn</h2>
				<p class="description">Returns a column (or column vector) from the matrix.</p>
				<h3>Syntax:</h3>
				<pre>.getColumn(column);</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The column position (starting from <code>0</code>, to <code>columns-1</code>).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix containing the specified column.</li>
				</ul>
				<h3>Example:</h3>
				<p>The following example will print the column vector <code>[0, 0, 1]</code>:</p>
				<pre>
var A = new MAT().fromArray([
	[1, 0, 0],
	[0, 1, 0],
	[0, 0, 1]
]);
var column = A.getColumn(2);
document.write(column.toString());</pre>
			</div>
			<div class="section" id="getColumns">
				<a class="top" href="#">top</a>
				<h2>getColumns</h2>
				<p class="description">Returns the number of columns.</p>
				<h3>Syntax:</h3>
				<pre>.getColumns()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(integer) - The number of columns.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT().fromArray([
	[1, 0, 0],
	[0, 1, 0],
	[0, 0, 1]
]);
document.write(A.getColumns());</pre>
				<p>Will print the number 3.</p>
			</div>
			<div class="section" id="getLength">
				<a class="top" href="#">top</a>
				<h2>getLength</h2>
				<p class="description">Returns the number of elements (or length) of the matrix array.</p>
				<h3>Syntax:</h3>
				<pre>.getLength()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(integer) - The number of elements of the matrix array.</li>
				</ul>
				<h3>Example:</h3>	
				<pre>
var A = new MAT().fromArray([
	[1, 0, 0],
	[0, 1, 0],
	[0, 0, 1]
]);
document.write(A.getLength());</pre>
				<p>Will print the number 9.</p>
			</div>
			<div class="section" id="getRow">
				<a class="top" href="#">top</a>
				<h2>getRow</h2>
				<p class="description">Returns a row (row vector) from the matrix.</p>
				<h3>Syntax:</h3>
				<pre>.getRow(row)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The row position (starting from <code>0</code>, to <code>rows-1</code>).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix containing the specified row.</li>
				</ul>
				<h3>Example:</h3>
				<p>The following example will print the row vector <code>[0, 1, 0]</code>.</p>
				<pre>
var A = new MAT().fromArray([
	[1, 0, 0],
	[0, 1, 0],
	[0, 0, 1]
]);
var row = A.getRow(1);
document.write(row.toString());</pre>
			</div>
			<div class="section" id="getRows">
				<a class="top" href="#">top</a>
				<h2>getRows</h2>
				<p class="description">Returns the number of rows.</p>
				<h3>Syntax:</h3>
				<pre>.getRows()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(integer) - The number of rows.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT().fromArray([
	[1, 0, 0],
	[0, 1, 0],
	[0, 0, 1]
]);
document.write(A.getRows());</pre>
				<p>Will print the number 3.</p>
			</div>
			<div class="section" id="getShape">
				<a class="top" href="#">top</a>
				<h2>getShape</h2>
				<p class="description">Returns the shape (or the dimensions) of the matrix.</p>
				<h3>Syntax:</h3>
				<pre>.getShape()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - An array of the form <code>[rows, columns]</code>.</li>
				</ul>
				<h3>Example:</h3>
				<p>For a 3x4 matrix the following code will print the array <code>[3, 4]</code>:</p>
				<pre>
var A = new MAT(3, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);				
document.write(A.getShape());</pre>
			</div>
			<div class="section" id="getValue">
				<a class="top" href="#">top</a>
				<h2>getValue</h2>
				<p class="description">Returns the value at the specified <code>row</code> and <code>column</code> values.</p>
				<h3>Syntax:</h3>
				<pre>.getValue(row, column)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The row position (from <code>0</code> to <code>rows-1</code>).</li>
					<li>(integer) - The column position (from <code>0</code> to <code>columns-1</code>).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The value at the specified position (complex numbers are treated as duplex of the form <code>[real,imag]</code>).</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
document.write(A.getValue(2, 3));</pre>
				<p>The previous code will print the number <code>12</code>.</p>
			</div>
			<div class="section" id="getValues">
				<a class="top" href="#">top</a>
				<h2>getValues</h2>
				<p class="description">Returns a copy of the matrix values, ordered from left to right and from top to bottom. This is the same as the <code>toString</code> method.</p>
				<h3>Syntax:</h3>
				<pre>.getValues()</pre>
				<h3>Arguments:</h3>
				<p>None</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A copy of the array containing the matrix values.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
document.write(A.getValues());</pre>
				<p>The previous code will print the array <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>.</p>
			</div>
			<div class="section" id="setRows">
				<a class="top" href="#">top</a>
				<h2>setRows</h2>
				<p class="description">Sets the number of rows of the matrix. This method should be used in conjuction with the <a href="#setColumns">setColumns</a> method in order to avoid undesired behaviours.</p>
				<h3>Syntax:</h3>
				<pre>.setRows(rows)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The number of rows.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The matrix object.</li>
				</ul>
				<h3>Example:</h3>
				<p>Let's say we want to transform a 3x2 matrix to a 1x6 matrix (or row vector):</p>
				<pre>
var A = new MAT(3, 2, [1, 2, 3, 4, 5, 6]);
// do some stuff here
A.setRows(1).setColumns(6);
document.write(A.getShape());</pre>
				<p>The previous code will print the array <code>[1, 6]</code>.</p>
			</div>
			<div class="section" id="setColumns">
				<a class="top" href="#">top</a>
				<h2>setColumns</h2>
				<p class="description">Sets the number of columns of the matrix. This method should be used in conjuction with the <a href="#setRows">setRows</a> method in order to avoid undesired behaviours.</p>
				<h3>Syntax:</h3>
				<pre>.setColumns(columns)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The number of columns.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The matrix object.</li>
				</ul>
				<h3>Example:</h3>
				<p>Let's say we want to transform a 3x2 matrix to a 6x1 matrix (or column vector):</p>
				<pre>
var A = new MAT(3, 2,[1, 2, 3, 4, 5, 6]);
// do some stuff here
A.setColumns(1).setRows(6);
document.write(A.getShape());</pre>
				<p>The previous code will print the array <code>[6, 1]</code>.</p>
			</div>
			<div class="section" id="setValue">
				<a class="top" href="#">top</a>
				<h2>setValue</h2>
				<p class="description">Sets the value at the specified position of the matrix.</p>
				<h3>Syntax:</h3>
				<pre>.setValue(row, column, value)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The row position (from <code>0</code> to <code>rows-1</code>).</li>
					<li>(integer) - The column position (from <code>0</code> to <code>columns-1</code>).</li>
					<li>(float|array) - The desired value.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The matrix object.</li>
				</ul>
				<h3>Example:</h3>
				<p>The following example sets the center value of a 3x3 matrix to 0.</p>
				<pre>matrix.setValue(1, 1, 0).</pre>
			</div>
			<div class="section" id="isSquare">
				<a class="top" href="#">top</a>
				<h2>isSquare</h2>
				<p class="description">Tells whether the matrix is a square matrix or not.</p>
				<h3>Syntax:</h3>
				<pre>.isSquare()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(boolean) - <code>true</code> if the matrix is square, <code>false</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
if (matrix.isSquare()) {
	// execute this code when the matrix is square
} else {
	// :(
}</pre>
			</div>
			<div class="section" id="isColumnVector">
				<a class="top" href="#">top</a>
				<h2>isColumnVector</h2>
				<p class="description">Tells whether the matrix is a column vector or not.</p>
				<h3>Syntax:</h3>
				<pre>.isColumnVector()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(boolean) - <code>true</code> when the matrix is a column vector, <code>false</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
if (matrix.isColumnVector()) {
	// matrix is a column vector
} else {
	// other code
}</pre>
			</div>
			<div class="section" id="isRowVector">
				<a class="top" href="#">top</a>
				<h2>isRowVector</h2>
				<p class="description">Tells whether the matrix is a row vector or not.</p>
				<h3>Syntax:</h3>
				<pre>.isRowVector()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(boolean) - <code>true</code> when the matrix is a row vector, <code>false</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
if (matrix.isColumnVector()) {
	// matrix is a row vector
} else {
	// other code
}</pre>
			</div>
			<div class="section" id="isVector">
				<a class="top" href="#">top</a>
				<h2>isVector</h2>
				<p class="description">Tells whether the matrix is a vector (1 row or 1 column) or not.</p>
				<h3>Syntax:</h3>
				<pre>.isVector()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(boolean) - <code>true</code> when the matrix is a vector, <code>false</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
if (matrix.isVector()) {
	// the matrix is a vector
} else {
	// other code
}</pre>
			</div>
			<div class="section" id="isSameSize">
				<a class="top" href="#">top</a>
				<h2>isSameSize</h2>
				<p class="description">Compares the shape of the matrix against the one in the argument.</p>
				<h3>Syntax:</h3>
				<pre>.isSameSize(matrix)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(object) - Another matrix</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(boolean) - <code>true</code> when both matrices have the same shape (same number of rows and columns).</li>
				</ul>
				<h3>Example:</h3>
				<p>The following example compares two matrices that have the same number of rows and columns and outputs the string <i>same size</i>:</p>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
var B = new MAT(3, 3, [9, 8, 7, 6, 5, 4, 3, 2, 1]);

if (A.isSameSize(B)) {
	document.write('same size');
} else {
	documenet.write('different size');
}</pre>
			</div>
			<div class="section" id="add">
				<a class="top" href="#">top</a>
				<h2>add</h2>
				<p class="description">Performs the addition of two matrices (<strong>A</strong> + <strong>B</strong>).</p>
				<h3>Syntax:</h3>
				<pre>.add(matrix)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(object) - A matrix object.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix with the result.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the ones of the first matrix, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
var B = new MAT(3, 3, [9, 8, 7, 6, 5, 4, 3, 2, 1]);

var C = A.add(B);

//     [1, 2, 3]   [9, 8, 7]
// C = [4, 5, 6] + [6, 5, 4]
//     [7, 8, 9]   [3, 2, 1]

document.write(C.toString()); // outputs "10, 10, 10, 10, 10, 10, 10, 10, 10"
document.write(A.toString()); // outputs "1, 2, 3, 4, 5, 6, 7, 8, 9"

// Now with the overwrite attribute set to true
A.overwrite = true;
A.add(B);

document.write(A.toString()); // outputs "10, 10, 10, 10, 10, 10, 10, 10, 10"</pre>
			</div>
			<div class="section" id="subtract">
				<a class="top" href="#">top</a>
				<h2>subtract</h2>
				<p class="description">Performs the subtraction of two matrices from left to right (<strong>A</strong> - <strong>B</strong>).</p>
				<h3>Syntax:</h3>
				<pre>.subtract(matrix)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(object) - A matrix object.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix with the result.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the ones of the first matrix, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
var B = new MAT(3, 3, [9, 8, 7, 6, 5, 4, 3, 2, 1]);

var C = A.subtract(B);

//     [1, 2, 3]   [9, 8, 7]
// C = [4, 5, 6] - [6, 5, 4]
//     [7, 8, 9]   [3, 2, 1]

document.write(C.toString()); // outputs "-8, -6, -4, -2, 0, 2, 4, 6, 8"
document.write(A.toString()); // outputs "1, 2, 3, 4, 5, 6, 7, 8, 9"

// Now with the overwrite attribute set to true
A.overwrite = true;
A.subtract(B);

document.write(A.toString()); // outputs "-8, -6, -4, -2, 0, 2, 4, 6, 8"</pre>
			</div>
			<div class="section" id="product">
				<a class="top" href="#">top</a>
				<h2>product</h2>
				<p class="description">Performs the product of two matrices (from left to right, <strong>A</strong> x <strong>B</strong>). The number of columns of the first matrix must match the number of rows of the second one.</p>
				<p class="description">This is the naive product algorithm. The Strassen's algorithm is in the TODO list.</p>
				<h3>Syntax:</h3>
				<pre>.product(matrix)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(object) - A matrix object.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix with the result.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the ones of the first matrix, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
var B = new MAT(3, 3, [1, 0, 1, 0, 1, 0, 0, 1, 1]);

var C = A.product(B);

//     [1, 2, 3]   [1, 0, 1]
// C = [4, 5, 6] * [0, 1, 0]
//     [7, 8, 9]   [0, 1, 1]

document.write(C.toString()); // outputs "1, 5, 4, 4, 11, 10, 7, 17, 16"

// Now with the overwrite attribute set to true
A.overwrite = true;
A.product(B);

document.write(A.toString()); // outputs "1, 5, 4, 4, 11, 10, 7, 17, 16"</pre>
			</div>
			<div class="section" id="hadamardProduct">
				<a class="top" href="#">top</a>
				<h2>hadamardProduct</h2>
				<p class="description">Performs the Hadamard product of two matrices (from left to right, A * B).</p>
				<h3>Syntax:</h3>
				<pre>.hadamardProduct(matrix)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(object) - A matrix object.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix with the result.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
var B = new MAT(3, 3, [1, 0, 1, 0, 1, 0, 0, 1, 1]);

var C = A.hadamardProduct(B);

//     [1, 2, 3]   [1, 0, 1]
// C = [4, 5, 6] o [0, 1, 0]
//     [7, 8, 9]   [0, 1, 1]

document.write(C.toString()); // outputs "1, 0, 3, 0, 5, 0, 0, 8, 9"

// Now with the overwrite attribute set to true
A.overwrite = true;
A.product(B);

document.write(A.toString()); // outputs "1, 0, 3, 0, 5, 0, 0, 8, 9"</pre>
			</div>
			<div class="section" id="scalarProduct">
				<a class="top" href="#">top</a>
				<h2>scalarProduct</h2>
				<p class="description">Performs the scalar product between the matrix and a scalar.</p>
				<h3>Syntax:</h3>
				<pre>.scalarProduct(value)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(float|array) - A scalar value.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix with the result.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the ones of the first matrix, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [1, 2, 3, 4]);

document.write(A.scalarProduct(2).toString()); // outputs "1, 4, 6, 8"</pre>
			</div>
			<div class="section" id="transpose">
				<a class="top" href="#">top</a>
				<h2>transpose</h2>
				<p class="description">Returns the transpose matrix.</p>
				<h3>Syntax:</h3>
				<pre>.transpose()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The matrix transposed.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the previous ones, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);


//     [1, 2, 3, 4]
// A = [5, 6, 7, 8]
//     [9,10,11,12]

var C = A.transpose();

//     [1, 5, 9]
// C = [2, 6,10]
//     [3, 7,11]
//     [4, 8,12]

document.write(C.toString()); // outputs "1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12"</pre>
			</div>
			<div class="section" id="hermitian">
				<a class="top" href="#">top</a>
				<h2>hermitian</h2>
				<p class="description">Returns the hermitian matrix (conjugate transpose).</p>
				<h3>Syntax:</h3>
				<pre>.hermitian()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The hermitian matrix.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the previous ones, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [3, [2,3], [2,-1], 1]);

document.write(A.hermitian().toString()); // outputs "3, [2,1], [2,-3], 1"</pre>
			</div>
			<div class="section" id="trace">
				<a class="top" href="#">top</a>
				<h2>trace</h2>
				<p class="description">Returns the trace of the matrix. That is, the sum of all the elements in the main diagonal.</p>
				<h3>Syntax:</h3>
				<pre>.trace()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The trace of the matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [3, [2,3], [2,-1], 1]);
document.write(A.trace());</pre>
				<p>The previous code will print 4.</p>
			</div>
			<div class="section" id="upperTrace">
				<a class="top" href="#">top</a>
				<h2>upperTrace</h2>
				<p class="description">Returns the trace of the matrix upper diagonals.</p>
				<h3>Syntax:</h3>
				<pre>.upperTrace(diagonal)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The position of the upper diagonal (starting from <code>0</code> for the main diagonal to <code>columns-1</code>).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The trace of the upper diagonal.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(4, 4, [
	 1, 2, 3, 4, 
	 5, 6, 7, 8, 
	 9,10,11,12,
	13,14,15,16
]);
document.write(A.upperTrace(1)); // outputs 21 (2 + 7 + 12)
document.write(A.upperTrace(2)); // outputs 11 (3 + 8)</pre>
			</div>
			<div class="section" id="lowerTrace">
				<a class="top" href="#">top</a>
				<h2>lowerTrace</h2>
				<p class="description">Returns the trace of the matrix lower diagonals.</p>
				<h3>Syntax:</h3>
				<pre>.lowerTrace(diagonal)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The position of the lower diagonal (starting from <code>0</code> for the main diagonal to <code>rows-1</code>).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The trace of the lower diagonal.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT({
	rows: 4,
	columns: 4,
	values: [
	 1, 2, 3, 4, 
	 5, 6, 7, 8, 
	 9,10,11,12,
	13,14,15,16]
});

document.write(A.lowerTrace(1)); // outputs 30 (5 + 10 + 15)
document.write(A.lowerTrace(2)); // outputs 23 (9 + 14)</pre>
			</div>
			<div class="section" id="minor">
				<a class="top" href="#">top</a>
				<h2>minor</h2>
				<p class="description">Returns a smaller matrix obtained by removing the row and the column at a specified position.</p>
				<h3>Syntax:</h3>
				<pre>.minor(row, column)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The row to remove from the matrix.</li>
					<li>(integer) - The column to remove from the matrix.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The minor matrix.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the previous ones, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
document.write(A.minor(2, 2).toString()); // outputs "1, 2, 4, 5"</pre>
			</div>
			<div class="section" id="determinant">
				<a class="top" href="#">top</a>
				<h2>determinant</h2>
				<p class="description">Returns the determinant of the matrix.</p>
				<p class="description">The algorithm uses the Laplace's formula by default, which is useful for small matrices. In order to speed things up, the user is able to select one of the following decomposition methods: lu, qr.</p>
				<h3>Syntax:</h3>
				<pre>.determinant([method])</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(string) - Optional, the method to be used (default is laplace. Options are: lu, qr).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The determinant.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when using the QR decomposition method, the result is the absolute value of the matrix determinant.</p>
				<h3>Example:</h3>
				<p>Following the example extracted from the <a href="http://en.wikipedia.org/wiki/Determinant" title="Determinant" target="_blank">wikipedia article</a>:</p>
				<pre>
var A = new MAT(3, 3, [-2, 2, 3, -1, 1, 3, 2, 0, -1]);
document.write(A.determinant()); // outputs 6
document.write(A.determinant('lu')); // throws "division by 0"
document.write(A.determinant('qr')); // outputs 5.999999999999997</pre>
				<p>Note that the previous matrix cannot be LU decomposed. LUP decomposition (LU with partial or full Pivoting), which overcomes this limitation, is not implemented yet.</p>
				<p>This other example, extracted from another <a href="http://en.wikipedia.org/wiki/QR_decomposition" title="QR decomposition" target="_blank">wikipedia article</a>, demonstrates the diferent values returned when using each method:</p>
				<pre>
var A = new MAT(3, 3, [12, -51, 4, 6, 167, -68, -4, 24, -41]);
document.write(A.determinant()); // outputs -85750 
document.write(A.determinant('lu')); // outputs -85749.99999999999
document.write(A.determinant('qr')); // outputs 85750.00000000009</pre>
			</div>
			<div class="section" id="det">
				<a class="top" href="#">top</a>
				<h2>det</h2>
				<p class="description">This is an alias for the <a href="#determinant">determinant</a> method.</p>
				<h3>Syntax:</h3>
				<pre>.det([method])</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(string) - Optional, the method to be used (default is laplace. Options are: lu, qr).</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float|array) - The determinant.</li>
				</ul>
				<h3>Example:</h3>
				<p>View the previous <a href="#determinant">determinant</a> examples.</p>
			</div>
			<div class="section" id="gaussElimination">
				<a class="top" href="#">top</a>
				<h2>gaussElimination</h2>
				<p class="description">Performs the Gaussian elimination algorithm. This is the method teached at school to solve systems of linear equations.</p>
				<h3>Syntax:</h3>
				<pre>.gaussElimination()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The matrix in a triangular (or row echelon) form.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the previous ones, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<p>The following example is extracted from the <a href="http://en.wikipedia.org/wiki/Gaussian_elimination" title="Gaussian elimination" target="_blank">wikipedia article</a>:</p>
				<pre>
var A = new MAT(3, 3, [2, 1, -1, -3, -1, 2, -2, 1, 2]);

//     [ 2,  1, -1]
// A = [-3, -1,  2]
//     [-2,  1,  2]

var Extended = new MAT(3, 4, [2, 1, -1, 8, -3, -1, 2, -11, -2, 1, 2, -3]);

//            [ 2,  1, -1|  8]
// Extended = [-3, -1,  2|-11]
//            [-2,  1,  2| -3]

document.write(A.gaussElimination().toString()); // outputs "2,1,-1,0,0.5,0.5,0,0,-1"

// [2,   1,  -1]
// [0, 0.5, 0.5]
// [0,   0,  -1]

document.write(Extended.gaussElimination().toString()); // outputs "2,1,-1,8,0,0.5,0.5,1,0,0,-1,1"

// [2,   1,  -1| 8]
// [0, 0.5, 0.5| 1]
// [0,   0,  -1| 1]</pre>
			</div>
			<div class="section" id="solve">
				<a class="top" href="#">top</a>
				<h2>solve</h2>
				<p class="description">Performs the Gauss elimination method and then solves the system of linear equations using backward substitution.</p>
				<h3>Syntax:</h3>
				<pre>.solve(array)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(array) - An array with the constant terms.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A column vector with the result values.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT({
	rows: 3,
	columns: 3,
	values: [2, 1, -1, -3, -1, 2, -2, 1, 2]
});

var result = A.solve([8, -11, -3]);
document.write(result.toString()); // outputs "2, 3, -1"</pre>
			</div>
			<div class="section" id="gramSchmidt">
				<a class="top" href="#">top</a>
				<h2>gramSchmidt</h2>
				<p class="description">Performs the Gram-Schmidt process (orthonormalize a set of vectors).</p>
				<h3>Syntax:</h3>
				<pre>.gramSchmidt()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The set of vectors orthonormalized.</li>
				</ul>
				<p class="notify"><strong>Note:</strong> when the <code>overwrite</code> attribute is set to <code>true</code> the result values will overwrite the previous ones, returning a reference to itself instead of a new matrix.</p>
				<h3>Example:</h3>
				<pre>
var A = new MAT({
	rows: 3,
	columns: 3,
	values: [2, 1, -1, -3, -1, 2, -2, 1, 2]
});

var result = A.gramSchmidt();
document.write(result.toString());

//outputs:
// [ 0.48507125007266594, 0.41166465371081584,   0.7715167498104589]
// [ -0.7276068751089989, -0.2993924754260479,   0.6172133998483683]
// [-0.48507125007266594,  0.8607533668498878, -0.15430334996209222]

// We can check that they are normalized ...
document.write(result.getColumn(0).norm()); // outputs "1"
document.write(result.getColumn(1).norm()); // outputs "1"
document.write(result.getColumn(2).norm()); // outputs "1"

// ... and orthogonal
result.getColumn(0).transpose().product(result.getColumn(1)); // outputs "0"
result.getColumn(0).transpose().product(result.getColumn(2)); // outputs "-6.522560269672795e-16"
result.getColumn(1).transpose().product(result.getColumn(2)); // outputs "-7.494005416219807e-16"</pre>
				<p>Note that since javascript performs floating point operations we may not obtain an exact number, but a really close one.</p>
			</div>
			<div class="section" id="qrDecomposition">
				<a class="top" href="#">top</a>
				<h2>qrDecomposition</h2>
				<p class="description">Performs the QR decomposition, that is, obtains an orthogonal matrix Q and an upper triangular matrix R (<strong>A</strong> = <strong>QR</strong>).</p>
				<h3>Syntax:</h3>
				<pre>.qrDecomposition()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A duplex containing both Q and R matrices. Q matrix is at position 0, R matrix is at position 1.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT({
	rows: 3,
	columns: 3,
	values: [2, 1, -1, -3, -1, 2, -2, 1, 2]
});

var QR = A.qrDecomposition();

document.write(QR[0].toString());

// [ 0.48507125007266594, 0.41166465371081584,   0.7715167498104589]
// [ -0.7276068751089989, -0.2993924754260479,   0.6172133998483683]
// [-0.48507125007266594,  0.8607533668498878, -0.15430334996209222]

document.write(QR[1].toString());

// [      4.123105625617661,      0.727606875108999, -2.9104275004359956]
// [ -2.220446049250313e-16,     1.5718104959867514,  0.7110571291368639]
// [-2.7755575615628914e-15, -1.609823385706477e-15, 0.15430334996209327]</pre>
			</div>
			<div class="section" id="qr">
				<a class="top" href="#">top</a>
				<h2>qr</h2>
				<p class="description">This is an alias for the <a href="#qrDecomposition">qrDecomposition</a> method.</p>
				<h3>Syntax:</h3>
				<pre>.qr()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A duplex containing both QR matrices. Q matrix is at position 0, R matrix is at position 1.</li>
				</ul>
				<h3>Example:</h3>
				<p>View the previous <a href="qrDecomposition">qrDecomposition</a> example.</p>
			</div>
			<div class="section" id="luDecomposition">
				<a class="top" href="#">top</a>
				<h2>luDecomposition</h2>
				<p class="description">Performs the LU decomposition, that is, obtains a lower triangular matrix L and an upper triangular matrix U (<strong>A</strong> = <strong>LU</strong>)</p>
				<h3>Syntax:</h3>
				<pre>.luDecomposition()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A duplex containing both LU matrices. L matrix is at position 0, U matrix is at position 1.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT({
	rows: 3,
	columns: 3,
	values: [2, 1, -1, -3, -1, 2, -2, 1, 2]
});

var LU = A.luDecomposition();

document.write(LU[0].toString()); // outputs "1,0,0,-1.5,1,0,-1,4,1"

// [   1, 0, 0]
// [-1.5, 1, 0]
// [  -1, 4, 1]

document.write(LU[1].toString()); // outputs "2,1,-1,0,0.5,0.5,0,0,-1"

// [2,   1,  -1]
// [0, 0.5, 0.5]
// [0,   0,  -1]
				
// Then we can perform the product to obtain the original matrix
document.write(LU[0].product(LU[1]).toString()); // outputs "2,1,-1,-3,-1,2,-2,1,2"</pre>
			</div>
			<div class="section" id="lu">
				<a class="top" href="#">top</a>
				<h2>lu</h2>
				<p class="description">This is an alias for the <a href="#luDecomposition">luDecomposition</a> method.</p>
				<h3>Syntax:</h3>
				<pre>.lu()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(array) - A duplex containing both LU matrices. L matrix is at position 0, U matrix is at position 1.</li>
				</ul>
				<h3>Example:</h3>
				<p>View the previous <a href="luDecomposition">luDecomposition</a> example.</p>
			</div>
			<div class="section" id="eigenValues">
				<a class="top" href="#">top</a>
				<h2>eigenValues</h2>
				<p class="description">Obtains the eigenvalues of a square matrix using the QR algorithm. This method uses the attributes <code>maxrounds</code> and <code>error</code> to make sure the algorithm finishes in case the process does not converge.</p>
				<h3>Syntax:</h3>
				<pre>.eigenValues()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - On convergence returns a column vector containing the eigenvalues. It returns <code>null</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [2, -4, -1, -1]);
var eigenvalues = A.eigenValues();

document.write(eigenvalues.toString()); // outputs "2.9999995960226222,-1.9999995960225925"</pre>
				<p>Note: the previous example takes 32 rounds to reach a lower trace with a lower value than 0.000001.</p>
			</div>
			<div class="section" id="eigenVectors">
				<a class="top" href="#">top</a>
				<h2>eigenVectors</h2>
				<p class="description">Obtains the eigenvectors of a square matrix using the QR algorithm. This method uses the attributes <code>maxrounds</code> and <code>error</code> to make sure the algorithm finishes in case the process does not converge.</p>
				<p class="notify"><strong>Note:</strong> this method is not fully tested yet! Use at your own risk ;)</p>
				<h3>Syntax:</h3>
				<pre>.eigenVectors()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - On convergence returns a matrix containing the eigenvectors (column vectors). It returns <code>null</code> otherwise.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [2, -4, -1, -1]);
var eigenvectors = A.eigenVectors();

document.write(eigenvectors.toString());

// [0.970142532804957, -0.2425354943978082]
// [0.24253549439781444, 0.970142532804954]</pre>
			</div>
			<div class="section" id="identity">
				<a class="top" href="#">top</a>
				<h2>identity</h2>
				<p class="description">Returns the identity matrix <code>I</code>, a square matrix with ones in the main diagonal and zeros elsewhere.</p>
				<h3>Syntax:</h3>
				<pre>.identity(integer)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The size of the matrix.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new identity matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(2, 2, [2, -4, -1, -1]);
var I = new MAT().identity(2);

document.write(A.product(I).toString()); // outputs "2,-4,-1,-1"</pre>
			</div>
			<div class="section" id="diagonal">
				<a class="top" href="#">top</a>
				<h2>diagonal</h2>
				<p class="description">Returns a squared, diagonal matrix with different values in the main diagonal and zeros elsewhere.</p>
				<h3>Syntax:</h3>
				<pre>.diagonal(array)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(array) - An array containing the values for the main diagonal.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A squared, diagonal matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var D = new MAT().diagonal([1,2,3,4]);
document.write(D.toString());

// [1,0,0,0]
// [0,2,0,0]
// [0,0,3,0]
// [0,0,0,4]</pre>
			</div>
			<div class="section" id="pNorm">
				<a class="top" href="#">top</a>
				<h2>pNorm</h2>
				<p class="description">Returns the p-norm over the set of values of the matrix. To obtain the p-norm of a column vector from a matrix the <a href="#getColumn">getColumn</a> method should precede, or <a href="#getRow">getRow</a> for a row vector.</p>
				<h3>Syntax:</h3>
				<pre>.pNorm(float)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(float) - The value for p.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(float) - The p-norm.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var v = new MAT(3, 1, [1, 1, 1]);
document.write(v.pNorm(2)); // outputs "1.7320508075688772"
document.write(v.pNorm(1)); // outputs "3"</pre>
				<p>Note that for <code>p=1</code> we get the Taxicab norm (or Manhattan norm) and for <code>p=2</code> we get the Euclidean norm.</p>
				<pre>
var A = new MAT(2, 2, [2, 1, 1, 2]);
document.write(A.getColumn(0).pNorm(2)); // outputs 2.23606797749979</pre>
			</div>
			<div class="section" id="norm">
				<a class="top" href="#">top</a>
				<h2>norm</h2>
				<p class="description">Returns the Euclidean norm over the set of values of the matrix. To obtain the Euclidean norm of a column vector from a matrix the <a href="#getColumn">getColumn</a> method should precede, or <a href="#getRow">getRow</a> method for a row vector.</p>
				<p class="description">Note that this is the same as using the <a href="pNorm">pNorm</a> with 2 as argument.</p>
				<h3>Syntax:</h3>
				<pre>.norm()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(float) - The Euclidean norm.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var v = new MAT(3, 1, [1, 1, 1]);
document.write(v.norm()); // outputs "1.7320508075688772"

var A = new MAT(2, 2, [2, 1, 1, 2]);
document.write(A.getColumn(0).norm()); // outputs 2.23606797749979</pre>
			</div>
			<div class="section" id="toToeplitz">
				<a class="top" href="#">top</a>
				<h2>toToeplitz</h2>
				<p class="description">Turns a column or row vector to a Toeplitz matrix (each descending diagonal from left to right is constant).</p>
				<h3>Syntax:</h3>
				<pre>.toToeplitz(integer)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The number of columns.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A Toeplitz matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 1, [1, 2, 3]);
document.write(A.toToeplitz(5).toString());

// [1,0,0,0,0]
// [2,1,0,0,0]
// [3,2,1,0,0]
// [0,3,2,1,0]
// [0,0,3,2,1]
// [0,0,0,3,2]
// [0,0,0,0,3]

document.write(A.toToeplitz(2).toString());

// [1,0]
// [2,1]
// [3,2]
// [0,3]</pre>
			</div>
			<div class="section" id="inverse">
				<a class="top" href="#">top</a>
				<h2>inverse</h2>
				<p class="description">Returns the inverse matrix of a non-singular matrix. The process uses the Cramer's rule, which is useful to find the inverse of small matrices. For larger matrices the use of this method is not recommended.</p>
				<h3>Syntax:</h3>
				<pre>.inverse()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The inverse matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [2, -1, 0, -1, 2, -1, 0, -1, 2]);
var Ai = A.inverse();

document.write(Ai.toString());

// [0.75, 0.5, 0.25]
// [ 0.5,   1,  0.5]
// [0.25, 0.5, 0.75]

document.write(Ai.product(A).toString());

// [1,0,0]
// [0,1,0]
// [0,0,1]</pre>
			</div>
			<div class="section" id="pseudoInverse">
				<a class="top" href="#">top</a>
				<h2>pseudoInverse</h2>
				<p class="description">Returns the Moore-Penrose pseudoinverse (generalized inverse matrix).</p>
				<h3>Syntax:</h3>
				<pre>.pseudoInverse()</pre>
				<h3>Arguments:</h3>
				<p>None.</p>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - The pseudoinverse matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var A = new MAT(3, 3, [2, -1, 0, -1, 2, -1, 0, -1, 2]);
var Api = A.pseudoInverse();

document.write(Api.toString());

// [0.75, 0.5, 0.25]
// [ 0.5,   1,  0.5]
// [0.25, 0.5, 0.75]</pre>
				<p>In the previous example we can see that the pseudoinverse produces the same inverse matrix. This other example shows how to get the pseudoinverse of a n<i>x</i>m matrix:</p>
				<pre>
var A = new MAT(3, 2, [1, 2, 3, -1, -2, 1]);
var Api = A.pseudoInverse();

document.write(Api.toString());

// [               0.16,  0.19999999999999998,               -0.12]
// [0.41333333333333333, -0.06666666666666668, 0.10666666666666667]

document.write(Api.product(A).toString());

// [                     1, 2.7755575615628914e-17]
// [-5.551115123125783e-17,                      1]</pre>
				<p>We can see that the pseudoinverse is a left inverse.</p>
			</div>
			<div class="section" id="toVandermonde">
				<a class="top" href="#">top</a>
				<h2>toVandermonde</h2>
				<p class="description">Produces a Vandermonde matrix from a given set of values.</p>
				<h3>Syntax:</h3>
				<pre>.toVandermonde(integer)</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(integer) - The number of columns.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A Vandermonde matrix.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var V = new MAT({values: [1,2,3,4,5,6], overwrite: true}).toVandermonde(5);
document.write(V.toString());

// [1, 1,  1,   1,    1]
// [1, 2,  4,   8,   16]
// [1, 3,  9,  27,   81]
// [1, 4, 16,  64,  256]
// [1, 5, 25, 125,  625]
// [1, 6, 36, 216, 1296]</pre>
			</div>
			<div class="section" id="zero">
				<a class="top" href="#">top</a>
				<h2>zero</h2>
				<p class="description">Returns a matrix filled with zeros.</p>
				<h3>Syntax:</h3>
				<pre>.zero([array])</pre>
				<h3>Arguments:</h3>
				<ol>
					<li>(array) - Optional. The shape of the zero matrix.</li>
				</ol>
				<h3>Returns:</h3>
				<ul>
					<li>(object) - A new matrix filled with zeros.</li>
				</ul>
				<h3>Example:</h3>
				<pre>
var Z = new MAT().zero([3, 4]);
document.write(Z.toString());

// [0,0,0,0]
// [0,0,0,0]
// [0,0,0,0]</pre>
			</div>
		</div>
	</div>
</body>
</html>
